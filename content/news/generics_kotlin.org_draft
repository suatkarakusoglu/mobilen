#+title: Genericlerle Kodumuzu Biraz Esnetelim
#+date: [2023-10-27 Fri]
#+author: Sevban BayÄ±r
#+filetags: :Kotlin:YazÄ±lÄ±m:

[[https://www.linkedin.com/in/sevban-bayir][Sevban BayÄ±r]] yazdÄ±.

* Ä°Ã§erik
AdlarÄ± Ã¼zerinde Genericler kodlarÄ±mÄ±zÄ± daha esnek kÄ±lar ve aynÄ± zamanda
yazdÄ±ÄŸÄ±mÄ±z class'larÄ± farklÄ± veri tipleriyle kullanabilmek iÃ§in
boilerplate kod yazmaktan bizleri kurtarÄ±rlar.

Ã–rneÄŸin, kodumuzda bir liste oluÅŸtururken onun iÃ§erisine o an istediÄŸimiz veri tipini
koyabilmeyi bekleriz yani o an bize kullanÄ±cÄ±larÄ±n yaÅŸlarÄ±nÄ±n olduÄŸu bir
liste gerekiyorsa bir integer listesi; eÄŸer isimleri gerekiyorsa bir
string listesi oluÅŸturabilmeliyizdir ve Ã§oÄŸu dilde de bunu yapabiliriz.
Peki ama hiÃ§ merak ettiniz mi bunu yapabilmemizi saÄŸlayan mekanizma
nedir, kullandÄ±ÄŸÄ±mÄ±z programlama dili bu Ã¶zelliÄŸi bize nasÄ±l saÄŸlÄ±yor?

Bu yazÄ±mÄ±zda Kotlin Ã¶zelinde bunlara cevaplar arayacaÄŸÄ±z. Ã–nce bahsettiÄŸimiz Ã¶rneÄŸi kanlÄ± canlÄ± gÃ¶relim:

#+begin_src kotlin
  val names: List<String> = listOf("Sevban", "BayÄ±r")
  val ages: List<Int> = listOf(20, 23)
  val gpas: List<Double> = listOf(2.5, 3.6)
#+end_src

Ve hikayenin ana kahramanÄ± olan List arayÃ¼zÃ¼nÃ¼n Kotlin'de nasÄ±l tanÄ±mlandÄ±ÄŸÄ±na bakalÄ±m:

#+begin_src kotlin
  public interface List<out E> : Collection<E> {...}
#+end_src

Burada bizim generic tip parametremizi temsil ediyor. Generic tip
parametresiyle compiler'a "Bu arayÃ¼z herhangi bir tip(Int, Double,
String) ile Ã§aÄŸÄ±rÄ±labilir", outvariance anahtar kelimesine sonraki
bÃ¶lÃ¼mde deÄŸineceÄŸiz ancak ÅŸimdilik List'e verdiÄŸimiz tip parametresinin
alt tipleriyle kendisi arasÄ±nda bir deÄŸiÅŸebilirlik anlaÅŸmasÄ± imzalÄ±yoruz
diyebiliriz.

** Variance
List arayÃ¼zÃ¼nÃ¼n tanÄ±mlanÄ±ÅŸÄ±nÄ± ilk gÃ¶rdÃ¼ÄŸÃ¼mÃ¼zde
out anahtar kelimesini elbette sorguluyoruz. Neden sadece List olarak
tanÄ±mlanmamÄ±ÅŸ ki diyebiliyoruz. Ä°Ã§gÃ¼dÃ¼sel olarak, aÅŸaÄŸÄ±daki kod
parÃ§acÄ±ÄŸÄ±nÄ±n sorunsuz bir ÅŸekilde compile etmesini bekleyebiliriz:

#+begin_src kotlin
  var numberList : List<Number> = listOf(1,2,3)
  val intList : List<Int> = listOf(1,2,3)
  numberList = intList
#+end_src

Ã‡Ã¼nkÃ¼ Int, Number Ä±n alt tipidir, deÄŸil miÂ ? Evet Ã¶yledir, fakat gerekli
variance anahtar kelimesi kullanÄ±lmadÄ±ÄŸÄ± sÃ¼rece List, List in alt tipi
deÄŸildir.

Åimdi gelin Kotlinde var olan 3 tip variance durumunu inceleyelim:

- Invariance
- Covariance
- Contravariance

** Invariance
ClassÄ±nÄ±zÄ± tanÄ±mlarken generic tip parametresinden Ã¶nce herhangi bir
anahtar kelime kullanmazsanÄ±z classÄ±nÄ±zÄ± invariant yapmÄ±ÅŸ olursunuz.
Variance'lar arasÄ±nda en basit olanÄ±dÄ±r ve bize o classÄ± herhangi bir
tiple oluÅŸturabilmekten baÅŸka, yani generic yapÄ±larÄ±n en temel
Ã¶zelliÄŸini sunmaktan baÅŸka bir ÅŸey saÄŸlamaz.

#+begin_src kotlin
  // Parent
  abstract class Car

  // Child
  class Audi : Car()

  // Child
  class Mercedes : Car()

  class CarMechanic<T: Car>

  fun main() {
      var mechanic = CarMechanic<Audi>()
      // Buradan itibaren bu property'nin tipi CarMechanic<Audi>'dir
      // ve ona baÅŸka tipte bir ÅŸey(mesela CarMechanic<Mercedes> atanamaz.
      val genericMechanic: CarMechanic<Car> = mechanic // ğŸ‘ˆğŸ» Compiler hatasÄ± !
  }
#+end_src

Dikkat ederseniz invariance'ta generic kullanarak elde etmeyi
beklediÄŸimiz tek esneklik CarMechanic classÄ±nÄ± tanÄ±mlarken iÃ§erisine Car
classÄ± veya ondan tÃ¼retilmiÅŸ olan diÄŸer classlarÄ± verebilmemizdir.

TanÄ±mlanan class ile onun diÄŸer tÃ¼revleri arasÄ±nda herhangi bir deÄŸiÅŸebilirlik ilkesi sÃ¶z konusu deÄŸildir ve gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z Ã¼zere bunu yapmaya Ã§alÄ±ÅŸmak compile time'da hataya sebep olur.

** Covariance: out
Covariance, bir class'Ä±n alt tiplerini tÄ±pkÄ± kendisiymiÅŸ gibi kullanabilmek istediÄŸimizde generic tip parametremizin
yanÄ±na =out= anahtar kelimesini ekleyerek elde ettiÄŸimiz bir variance tipidir. Bu ÅŸekilde, yukarÄ±daki List tanÄ±mÄ±nda bahsettiÄŸimiz deÄŸiÅŸebilirlik anlaÅŸmasÄ±nÄ± imzalamÄ±ÅŸ oluruz.

#+begin_src kotlin
  //Parent
  abstract class Car

  //Child
  class Audi : Car()

  //Child
  class Mercedes : Car()

  class CarMechanic<out T: Car> {
      fun repair() {}
  }

  class Workshop {
      // Bu fonksiyon bizden bir Car tipiyle tanÄ±mlanmÄ±ÅŸ bir
      // CarMechanic paslamamÄ±zÄ± istiyor.
      fun addMechanic(mechanic: CarMechanic<Car>) { }
  }
  fun main() {
      val mechanic = CarMechanic<Audi>()
      val workshop = Workshop()

      // EÄŸer CarMechanic class'Ä±mÄ±z covariant(out) olarak
      // tanÄ±mlanmasaydÄ± bu satÄ±rdaki atamayÄ± yapamayacaktÄ±k.
      workshop.addMechanic(mechanic)
  }
#+end_src

** Contravariance: 'in'
Contravariance, covariance'Ä±n tam tersidir. ClassÄ±mÄ±zÄ±n generic tip parametresine =in= anahtar kelimesini ekleyerek bu classÄ±n belirttiÄŸimiz generic tip parametresi ve onun Ã¼st tipleriyle tanÄ±mlanabileceÄŸini belirtmiÅŸ oluruz.

#+begin_src kotlin
  interface Comparable<in T> {
      fun compareTo(other: T) : Int
  }

  fun doSomething(
      comparable: Comparable<Number>
  ) {
      val x : Comparable<Double> = comparable
  }
#+end_src

** Unsafe Variance
Dikkat ettiyseniz buraya kadar verdiÄŸimiz Ã¶rneklerde contravariance(in)
olarak tanÄ±mladÄ±ÄŸÄ±mÄ±z type parametreleri classlarÄ±mÄ±zÄ±n iÃ§erisindeki
fonksiyonlarda gerekiyorsa parametre olarak aldÄ±k fakat return type
olarak atamadÄ±k; tam tersi covariance olarak tanÄ±mladÄ±ÄŸÄ±mÄ±z type
parametrelerini de gerekiyorsa return type olarak verdik ancak parametre
olarak almadÄ±k.

EÄŸer bunlarÄ± yapsaydÄ±k kodumuzda "Unsafe Variance" olarak adlandÄ±rÄ±lan bir tÃ¼r tutarsÄ±zlÄ±ÄŸa sebep olmuÅŸ olacaktÄ±k. Gelin
bir Ã¶rnekle inceleyelim:

#+begin_src kotlin
  abstract class ReadOnlyBox<out T>(){
      abstract fun getItem(a:@UnsafeVariance T) :T
  }

  fun main(){
      val intBox: ReadOnlyBox<Int> = object : ReadOnlyBox<Int>() {
          override fun getItem(a: Int): Int {
              return a
          }
      }

      val anyBox: ReadOnlyBox<Number> = intBox
      val value: Number = anyBox.getItem(10.454434234324234)
      println(value)
  }

  //Output: 10
#+end_src

ReadOnlyBox adÄ±nda covariant bir class tanÄ±mladÄ±k ve iÃ§erisinde Unsafe
Variance iÃ§eren bir fonksiyon oluÅŸturduk. Daha sonra intBox ve numberBox
ÅŸeklinde 2 adet ReadOnlyBox objesi oluÅŸturduk ve intBox'Ä± numberBox'a
atadÄ±k.

Daha doÄŸrusu atayabildik Ã§Ã¼nkÃ¼ ReadOnlyBox bir covariant class
ve Number ile oluÅŸturduÄŸumuz bir objesine Int olanÄ±nÄ± yani alt
tiplerinden biriyle oluÅŸturulmuÅŸ olanÄ±nÄ± atayabiliriz.

Nihayetinde numberBox'Ä±mÄ±zÄ±n getItem fonksiyonuna bir float gÃ¶nderdiÄŸimizde onu
gizlice integer'a dÃ¶nÃ¼ÅŸtÃ¼rmÃ¼ÅŸ olduk. Burada bu basit Ã¶rnek Ã¼zerinden Ã§ok
aÃ§Ä±k bir ÅŸekilde ortada gibi gÃ¶rÃ¼nebilir fakat yine de Unsafe Variance
kullanÄ±mÄ±nda karÅŸÄ±laÅŸabileceÄŸimiz bir hatayÄ± Ã¶nceden gÃ¶rmek bize
debuglarÄ±mÄ±zda zaman kazandÄ±rabilir.

** KapanÄ±ÅŸ
SonuÃ§ olarak, Generic yapÄ±lar programlamada Ã§ok temel ve Ã¶nemli bir konsepttir. Genericler sayesinde az bir kodla proje genelinde kullanacaÄŸÄ±mÄ±z yapÄ±lar oluÅŸturabilir ve projemize bir bÃ¼tÃ¼nlÃ¼k saÄŸlayabiliriz.

Bir sonraki yazÄ±da gÃ¶rÃ¼ÅŸmek Ã¼zere. BugsÄ±z kodlamalar :)

** KaynakÃ§a
- [[https://kotlinlang.org/docs/generics.html#declaration-site-variance][Kotlin DokÃ¼mantasyonu]]
