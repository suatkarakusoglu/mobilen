#+title: S.O.L.I.D. Prensipleri Nedir?
#+date: [2024-09-12 Thu]
#+author: Åevval MertoÄŸlu
#+filetags: :YazÄ±lÄ±m:

[[https://tr.linkedin.com/in/sevvalmertoglu8][Åevval Mertoglu]] yazdÄ±.

[[file://solid_principles_cover.jpg]]

* Ä°Ã§erik
=SOLID= prensipleri, nesne yÃ¶nelimli programlamada yazÄ±lÄ±m tasarÄ±mÄ±nÄ±n temelini oluÅŸturan beÅŸ Ã¶nemli prensibi ifade eder.

Robert C. Martin, diÄŸer adÄ±yla "Uncle Bob" tarafÄ±ndan popÃ¼ler hale getirilen bu prensipler ilk olarak 2000 yÄ±lÄ±nda yayÄ±nlanan "Design Principles and Design Patterns" makalesinde dile getirilmiÅŸtir. KÄ±saltmasÄ± ise Michael Feathers tarafÄ±ndan tanÄ±mlanmÄ±ÅŸtÄ±r.

** SOLID Neden Ã–nemli?
Bu prensipler, yazdÄ±ÄŸÄ±mÄ±z kodun sÃ¼rdÃ¼rÃ¼lebilirliÄŸini, esnekliÄŸini ve anlaÅŸÄ±labilirliÄŸini arttÄ±rmamÄ±za yardÄ±mcÄ± olur. BÃ¶ylece temiz bir kod yazmÄ±ÅŸ oluruz. YaptÄ±ÄŸÄ±mÄ±z projeyi bu prensiplere mÃ¼mkÃ¼n olduÄŸunca baÄŸlÄ± kalarak yazmaya Ã§alÄ±ÅŸmalÄ±yÄ±z.

*** S: Single Responsibility Principle (Tek Sorumluluk Prensibi)
[[file://solid_single_responsibility.jpg]]

YazdÄ±ÄŸÄ±mÄ±z sÄ±nÄ±f ya da modÃ¼l isviÃ§re Ã§akÄ±sÄ± gibi her iÅŸi yapmamalÄ±. Sadece ilgili olduÄŸu tek bir iÅŸi yapmalÄ±. Bu ÅŸekilde yazdÄ±ÄŸÄ±mÄ±z kod karmaÅŸÄ±klÄ±ktan daha uzak olur. AyrÄ±ca, kodun daha az baÄŸÄ±mlÄ± ve daha esnek olmasÄ±nÄ± saÄŸlayarak, deÄŸiÅŸikliklerin daha kolay ve hÄ±zlÄ± bir ÅŸekilde yapÄ±lmasÄ±nÄ± da saÄŸlar.

Ã–rnek verecek olursak:
#+begin_src swift
  class UserService {
      var userFirstName: String
      var userLastName: String

      init(userFirstName: String, userLastName: String) {
          self.userFirstName = userFirstName
          self.userLastName = userLastName
      }

      func getName() -> String {
          return userFirstName + userLastName
      }

      func login() -> Bool {
          // GiriÅŸ iÅŸlemlerini yapmak iÃ§in
          return true
      }

      func logout() -> Bool {
          // Ã‡Ä±kÄ±ÅŸ iÅŸlemlerini yapmak iÃ§in
          return true
      }
  }
#+end_src

Bir UserService dosyamÄ±zÄ±n olduÄŸunu dÃ¼ÅŸÃ¼nelim. KullanÄ±cÄ±yÄ± servis etmekle ilgili olan bu sÄ±nÄ±f iÃ§erisinde oturum iÅŸlemleri olmamalÄ±. Bu, kodun Single Responsibility prensibine uymadÄ±ÄŸÄ± anlamÄ±na gelir.

Ä°ÅŸte doÄŸru yazÄ±mÄ±:

#+begin_src swift
  class UserService {
      var userFirstName: String
      var userLastName: String

      init(userFirstName: String, userLastName: String) {
          self.userFirstName = userFirstName
          self.userLastName = userLastName
      }

      func getName() -> String {
          return userFirstName + userLastName
      }
  }

  class AuthService {
      func login() -> Bool {
          // Login process
          return true
      }

      func logout() -> Bool {
          // Logout process
          return true
      }
  }
#+end_src
UserService sadece kullanÄ±cÄ± bilgilerini yÃ¶netir, AuthService ise oturum iÅŸlemlerini yÃ¶netir. BÃ¶ylece herkes kendi gÃ¶revini yapmÄ±ÅŸ olur.
*** O: Open/Closed Principle (AÃ§Ä±k/KapalÄ± Prensibi)
Bu ilkeye gÃ¶re, sÄ±nÄ±fÄ±mÄ±z geliÅŸime aÃ§Ä±k deÄŸiÅŸime kapalÄ± olmalÄ±dÄ±r. Bir sÄ±nÄ±fÄ±n veya fonksiyonun hazÄ±rda olan davranÄ±ÅŸÄ±nÄ±n korunup hiÃ§bir deÄŸiÅŸiklik yapÄ±lmadan sÄ±nÄ±fÄ±n veya fonksiyonun geliÅŸtirilebilir olmasÄ± anlamÄ±na gelir.

Ã–rnek verecek olursak:
#+begin_src swift
  class AuthService {
      func login(LoginType: String) -> Bool {
          // Login process
          if LoginType == "Teacher" {
              // Teacher login process
          } else if LoginType == "Student" {
              // Student login process
          }
          return true
      }

      func logout() -> Bool {
          // Logout process
          return true
      }
  }
#+end_src

KullanÄ±cÄ± tipine gÃ¶re farklÄ± oturum aÃ§ma seÃ§eneklerimiz varsa ve ileride yeni kullanÄ±cÄ± tipi gelirse aynÄ± ÅŸeyleri tekrar yapmamÄ±z gerekecek. Yani sÄ±nÄ±fÄ± deÄŸiÅŸtirmemiz gerekecek. Bu ilkeye gÃ¶re sÄ±nÄ±fÄ±n deÄŸiÅŸmesini deÄŸil geliÅŸmesini istiyoruz.

Ä°ÅŸte doÄŸru kullanÄ±mÄ±:

#+begin_src swift
  protocol IAuthService {
      func login() -> Bool
      func logout() -> Bool
  }

  class TeacherAuth: IAuthService {
      func login() -> Bool {
          // Teacher login process
          return true
      }

      func logout() -> Bool {
          // Teacher logout process
          return true
      }
  }

  class StudentAuth: IAuthService {
      func login() -> Bool {
          // Student login process
          return true
      }

      func logout() -> Bool {
          // Student logout process
          return true
      }
  }
#+end_src

Her bir kullanÄ±cÄ± tipi iÃ§in ayrÄ± sÄ±nÄ±f oluÅŸturduk. AuthService protokolÃ¼, login ve logout iÅŸlevlerinin tanÄ±mlarÄ±nÄ± iÃ§erir. Yeni bir kullanÄ±cÄ± tipi eklemek istediÄŸimizde AuthService sÄ±nÄ±fÄ±nÄ± deÄŸiÅŸtirmeden ekleyebileceÄŸiz.

*** L: Liskov Substitution Principle (Liskov Yerine GeÃ§me Prensibi)
Bu ilkenin temel amacÄ±, alt sÄ±nÄ±flarÄ±n, Ã¼st sÄ±nÄ±flarÄ±nÄ±n yerine geÃ§ebildiÄŸi bir sistem tasarlamaktÄ±r. KÄ±saca bir Ã¼st sÄ±nÄ±fÄ±n tÃ¼m davranÄ±ÅŸlarÄ±nÄ± ve Ã¶zelliklerini koruyarak alt sÄ±nÄ±flarÄ±n kendi Ã¶zelliklerini ve davranÄ±ÅŸlarÄ±nÄ± eklemesine olanak tanÄ±maktÄ±r.

Bu ilkeye gÃ¶re bir alt sÄ±nÄ±fÄ±n, Ã¼st sÄ±nÄ±fÄ±n tÃ¼m davranÄ±ÅŸlarÄ±nÄ± deÄŸiÅŸtirmeden veya bozucu bir etki yapmadan geniÅŸletebilmesi gerekir.

Ã–rnek olarak, DikdÃ¶rtgen ve Kare sÄ±nÄ±flarÄ±nÄ± ele alalÄ±m. Kare, bir dikdÃ¶rtgendir. Ancak, kareyi dikdÃ¶rtgenden miras alarak oluÅŸturursak, Liskov Yerine GeÃ§me Prensibiâ€™ni ihlal edebiliriz. Bu durumda kare sÄ±nÄ±fÄ±, dikdÃ¶rtgenin yerine geÃ§tiÄŸinde beklenmeyen davranÄ±ÅŸlar sergileyebilir. (geniÅŸlik veya yÃ¼kseklik deÄŸiÅŸtirildiÄŸinde)

Bu durumda hem dikdÃ¶rtgen hem de kare, â€œshapeâ€ protokolÃ¼nÃ¼ uygular. Her iki sÄ±nÄ±f da ÅŸekil tÃ¼rÃ¼nde kullanÄ±labilir. Bu ÅŸekilde, kare ve dikdÃ¶rtgen arasÄ±ndaki farklÄ±lÄ±klardan oluÅŸan sorunlar giderilir ve Liskov Substitution Prensibi'ne uyulmuÅŸ olunur.

*** I: Interface Segregation Principle (ArayÃ¼z AyÄ±rma Prensibi)
Bu ilke bize pek Ã§ok gÃ¶revi olan bir interface yapmamamÄ±z gerektiÄŸini sÃ¶ylÃ¼yor. Ä°htiyaÃ§lara gÃ¶re ayrÄ± gÃ¶revler iÃ§in amacÄ±na hizmet eden birden Ã§ok interface oluÅŸturmalÄ±yÄ±z.

AynÄ± Ã¶rnek Ã¼zerinden anlatacak olursak. Diyelim ki Student sadece giriÅŸ iÅŸlemi yapabilsin Ã§Ä±kÄ±ÅŸ iÅŸlemini kullanmasÄ±n. Bu durumda:

#+begin_src swift
  protocol LoginService {
      func login() -> Bool
  }

  protocol LogoutService {
      func logout() -> Bool
  }
#+end_src

GiriÅŸ ve Ã§Ä±kÄ±ÅŸ iÅŸlemleri iÃ§in ayrÄ± protokoller tanÄ±mladÄ±m. BÃ¶ylece farklÄ± gÃ¶revler yapan ayrÄ± interfaceâ€™ler oluÅŸturmuÅŸ olduk.
#+begin_src swift
  class TeacherAuth: LoginService, LogoutService {
      func login() -> Bool {
          // Teacher login process
          return true
      }

      func logout() -> Bool {
          // Teacher logout process
          return true
      }
  }

  class StudentAuth: LoginService {
      func login() -> Bool {
          // Student login process
          return true
      }
  }
#+end_src

Studentâ€™a logout fonksiyonunu kullanmasÄ± iÃ§in zorlamadan, Interface Segregation Prensibine uyarak kodumuzu yazmÄ±ÅŸ olduk.

*** D: Dependency Inversion Principle (BaÄŸÄ±mlÄ±lÄ±ÄŸÄ± Tersine Ã‡evirme Prensibi)
Bu ilkeye gÃ¶re, bir alt sÄ±nÄ±fta doÄŸabilecek bir deÄŸiÅŸiklik Ã¼st sÄ±nÄ±fÄ± etkilememesi gerekiyor. KÄ±saca Ã¼st seviye sÄ±nÄ±flar, alt seviye sÄ±nÄ±flara doÄŸrudan baÄŸÄ±mlÄ± olmamalÄ±dÄ±r. Bu ilke ile bir sÄ±nÄ±fÄ±n somut bir sÄ±nÄ±fa veya modÃ¼le doÄŸrudan baÄŸÄ±mlÄ± olmamasÄ±, bunun yerine bir arayÃ¼z veya soyutlama Ã¼zerinden baÄŸÄ±mlÄ±lÄ±k kurmasÄ± saÄŸlanÄ±r.

Ã–rnek olarak:

KullanÄ±cÄ±ya bir bildirim gÃ¶ndermek istiyoruz. Notification sÄ±nÄ±fÄ±nÄ±n email sÄ±nÄ±fÄ±na doÄŸrudan baÄŸÄ±mlÄ± olduÄŸu bir durumda:

#+begin_src swift
  class Email {
      func sendEmail() {
          print("Email gÃ¶nderiliyor")
      }
  }

  class Notification {
      func send() {
          let email = Email()
          email.sendEmail()
      }
  }
#+end_src
Ä°lerleyen zamanda email sÄ±nÄ±fÄ±nÄ±n iÃ§indeki herhangi bir deÄŸiÅŸiklik Notification sÄ±nÄ±fÄ±nÄ± doÄŸrudan etkileyeceÄŸi iÃ§in bu kullanÄ±m Dependency Inversion Prensibine uymaz.

Diyelim ki kullanÄ±cÄ±ya farklÄ± platformlar Ã¼zerinden bir bildirim gÃ¶ndermek istiyoruz. Bu durumda, Message isminde send metodunu iÃ§eren bir protokol tanÄ±mladÄ±k. Bu method, Email, Sms ve PhoneEvent sÄ±nÄ±flarÄ± tarafÄ±ndan uygulanacak.

#+begin_src swift
  protocol Message {
      func send()
  }

  class Email: Message {
      func send() {
          print("Email gÃ¶nderiliyor")
      }
  }

  class Sms: Message {
      func send() {
          print("Sms gÃ¶nderiliyor")
      }
  }

  class PhoneEvent: Message {
      func send() {
          print("Event gÃ¶nderiliyor")
      }
  }

  class Notification {
      func send(message: Message) {
          message.send()
      }
  }
#+end_src

Her bir alt sÄ±nÄ±f, send metodunu kendine Ã¶zgÃ¼ ÅŸekilde tanÄ±mlar. Notification sÄ±nÄ±fÄ± (Ã¼st sÄ±nÄ±f) Message protokolÃ¼ne baÄŸÄ±mlÄ±dÄ±r. Send metodunu alÄ±r ve protokolÃ¼ uygulayan herhangi bir sÄ±nÄ±fÄ±n send metodunu Ã§aÄŸÄ±rÄ±r.

#+begin_src swift
  let email = Email()
  let sms = Sms()
  let phoneEvent = PhoneEvent()

  let notification = Notification()

  notification.send(message: email)
  notification.send(message: sms)
  notification.send(message: phoneEvent)
#+end_src

Bu sayede, yeni mesaj tÃ¼rleri eklemek veya mevcut tÃ¼rleri deÄŸiÅŸtirmek, Notification sÄ±nÄ±fÄ±nÄ± etkilemez. Dependency Inversion prensibine uymuÅŸ oluruz.

BugÃ¼nlÃ¼k SOLID Prensiplerinden bahsettiÄŸim yazÄ±m bu kadardÄ± bir sonraki yazÄ±mda gÃ¶rÃ¼ÅŸmek Ã¼zere! ğŸ‘‹ğŸ»ğŸ‘‹ğŸ»
