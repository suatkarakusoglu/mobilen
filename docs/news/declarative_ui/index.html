<!-- Generated from 9f7d618 on 2024-09-13 @ 14:27 with Emacs 30.0.60 (Org mode 9.7.9) -->
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta author="Mobilen - Suat Karakuşoğlu"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" type="image/png" href="/img/favicon.png"/><link rel="alternative" type="application/rss+xml" title="Mobilen Yazılar" href="https://mobilen.art/rss/news.xml"/><link rel="stylesheet" href="https://mobilen.art/fonts/iosevka-aile/iosevka-aile.css"/><link rel="stylesheet" href="https://mobilen.art/fonts/jetbrains-mono/jetbrains-mono.css"/><link rel="stylesheet" href="https://mobilen.art/css/code.css"/><link rel="stylesheet" href="https://mobilen.art/css/site.css"/><link rel="stylesheet" href="https://mobilen.art/css/code_highlighter_dark_theme.css"/><title>Declarative Yaklaşım ve Tasarım - Mobilen</title></head><body><header class="site-header"><div class="container"><div class="site-title"><h1>Mobilen</h1></div></div><div class="site-masthead"><div class="container"><nav class="nav"><a class="nav-link" href="/">Anasayfa</a> <a class="nav-link" href="/magazines/">Dergiler</a> <a class="nav-link" href="/news/">İçerikler</a> </nav></div></div></header><div class="container"><div class="site-post"><h1 class="site-post-title">Declarative Yaklaşım ve Tasarım</h1><a class="tag" href="https://mobilen.art/tags/tasarım/">Tasarım #6</a><a class="tag" href="https://mobilen.art/tags/yazılım/">Yazılım #35</a><a class="tag" href="https://mobilen.art/tags/react/">React #1</a><a class="tag" href="https://mobilen.art/tags/swiftui/">SwiftUI #3</a><a class="tag" href="https://mobilen.art/tags/flutter/">Flutter #2</a><p class="site-post-meta">8 min read | November 15, 2023</p><div id="content"><p>
<a href="https://tr.linkedin.com/in/suat-karakusoglu">Suat Karakuşoğlu</a> yazdı.
</p>


<div id="org38a43bb" class="figure">
<p><img src="/img/declarative_ui_magic.jpg" class="content-image" width="100%">
</p>
<p><span class="figure-number">Figure 1: </span>Photo by <a href="https://unsplash.com/@art_maltsev?utm_content=creditCopyText&amp;utm_medium=referral&amp;utm_source=unsplash">Artem Maltsev</a></p>
</div>
<h2><a id="i̇çerik" class="anchor" href="#i̇çerik">¶</a>İçerik</h2><div class="outline-text-2" id="text-org924df1c">
<p>
Merhabalar,
</p>

<p>
Arayüz tasarlamak yazıyla resim yapabilmek.
</p>

<p>
Yalnızca, resmi sürekli güncel bilgilere göre düzenlemeniz, bazende etkileşimli hale getirmeniz gibi bir ressamdan daha fazlasını gerektirebiliyor.
</p>

<p>
Uzun zamandır türlü diller ve araçlar ile farklı tuvallare arayüz tasarımları yapmaktayız.
</p>

<p>
Bu araçlar hakkında ve arayüz tasarımında değişen pratiklerin nihayetinde nasıl declarative yaklaşımda buluştuğundan bahsedeceğim.
</p>
</div>
<h3><a id="imperative-tasarım" class="anchor" href="#imperative-tasarım">¶</a>Imperative Tasarım</h3><div class="outline-text-3" id="text-org4d42b79">
<p>
Declarative taraftan bahsetmeden önce daha çok pratik ettiğimiz <code>imperative</code> yaklaşımdan bahsedelim.
</p>

<p>
Bir ekranın nasıl çizilmesi gerektiğine dair tüm adımları özellikle belirterek uyguladığımız tasarım yaklaşımı <code>imperative</code> tasarım olarak değerlendirilebilir.
</p>

<p>
Declarative veya Imperative yaklaşım yalnızca UI&rsquo;da karşımıza çıkmıyor.
</p>

<p>
Henüz üniversite yıllarında sıralama algoritmalarına denk geldiğimde heyecanlanmıştım, bubble&rsquo;indan merge sort&rsquo;una, timsort&rsquo;undan quick sort&rsquo;una.
</p>

<p>
Hepsi ile örnekler yapmış görselleştirmeler yapmaya çalışmıştım. Sonrasında ilk staja başladığım yerde kullanıcıları hangi algoritma ile nasıl sıralıyorsunuz gibi bir soru sorduğumda &rsquo;SORT&rsquo; yazıyoruz SQL&rsquo;de ve o bu işi yapıyor diye cevap almıştım :).
</p>
</div>
<h3><a id="beyan-ve-indirection" class="anchor" href="#beyan-ve-indirection">¶</a>Beyan ve Indirection</h3><div class="outline-text-3" id="text-org429f8de">
<p>
Sadece beyan / <code>declare</code> ederek işinizin ne olduğunu belirtip, sistemin bunu yapmasını beklemenin elbette bir çok avantajı var.
</p>

<p>
<code>Protocol</code> veya <code>Interface</code> dediğimiz yapılar ile dependency inversion yapıyorsunuz ve daha sonra yeni bir sıralama algoritması keşfedildiğinde, sistem sizi herhangi bir değişikliğe gerek bırakmadan daha verimli hale geliyor.
</p>

<p>
Declarative yani &rsquo;ol&rsquo; de olsun &rsquo;sırala&rsquo; de sıralasın ve nasıl yaptığına çok karışma felsefesini orada daha iyi anlamıştım.
</p>

<p>
Görsel tasarımdan örnek vermemiz gerekir ise; bir alert popup&rsquo;i tasarlayıp ekranda istediğiniz hangi noktadan çıkacağını hesaplayıp animasyonlarını belirleyip gerçeklemek <code>imperative</code> iken, sisteme ben alert göstereceğim ve verilerim şunlar gerisini sen hallet demekte <code>declarative</code> tarafı.
</p>

<p>
Bu sayede belki büyük ekran&rsquo;lı iPad&rsquo;de farklı bir yerden çıkarabilecekken popup, ufak ekranda daha uygun bir yerden çıkarma kararını işletim sistemi kendisi verebilir.
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">Yazılım&rsquo;ın temel teoremi indirection</a> beyan&rsquo;a dayalı <code>declarative</code> yaklaşımın izdüşümü.
</p>
<blockquote>
<p>
&ldquo;We can solve any problem by introducing an extra level of indirection.&rdquo;
</p>

<p>
&#x2014; <a href="https://en.wikipedia.org/wiki/Andrew_Koenig_(programmer)">Andrew Koenig</a>
</p>
</blockquote>
</div>
<h3><a id="declarative-tasarım-ve-verirsquonin-ilişkisi" class="anchor" href="#declarative-tasarım-ve-verirsquonin-ilişkisi">¶</a>Declarative Tasarım ve Veri&rsquo;nin ilişkisi</h3><div class="outline-text-3" id="text-org1d3d268">
<p>
<code>Declarative tasarım</code> matematiksel ifadeyle veriyi alıp arayüze dönüştüren bir fonksiyondur:
</p>
<blockquote>
<p>
declarativeTasarim(veri) -&gt; Arayuz
</p>
</blockquote>
</div>
<h3><a id="facebookrsquoun-etkisi" class="anchor" href="#facebookrsquoun-etkisi">¶</a>Facebook&rsquo;un etkisi</h3><div class="outline-text-3" id="text-org0e1cc3f">
<p>
Siyasal mecrada skandallara varabilecek derecede toplumu yönlendirme gücüne sebep olabilecek büyüklükte veriyi elinde bulunduran firma diyince diyince ilk akla gelen şirket elbette Facebook.
</p>

<p>
<a href="https://www.youtube.com/watch?v=8pDqJVdNa44">React belgeseli</a>nde geçen, reklam takımında ortaya çıkan arayüz geliştirme süreçlerindeki hantallık ve hatalar facebookta radikal bir çözümü gerekli kılmış.
</p>
</div>
<h3><a id="react-ve-devamı" class="anchor" href="#react-ve-devamı">¶</a>React ve devamı</h3><div class="outline-text-3" id="text-org3db1716">
<p>
Reklam takımındaki bir product engineer&rsquo;a garip gözlerle bakılmasına sebep olan sorusu şöyle:
</p>

<blockquote>
<p>
&rsquo;Tüm&rsquo; arayüzü herhangi bir &rsquo;veri&rsquo; değiştiğinde silip en baştan çizelim.
</p>
</blockquote>

<p>
Declaratıve tasarım fonksiyonu için olan bu matematiksel yaklaşımların gerçek dünyada ekonomik bir şekilde tatbik edilebilir hale getirmek zor olabiliyor.
</p>

<p>
Performanslı bir şekilde tüm tuvali tek bir değişiklikte sil baştan çizmek delice gelsede kulağa, pratikte bunu yapıcak yolların keşfiyle hiçte mantıksız değilmiş ampulunu kafalarda yakmıştır.
</p>
</div>
<h3><a id="diffing-ve-faydası" class="anchor" href="#diffing-ve-faydası">¶</a>Diffing ve Faydası</h3><div class="outline-text-3" id="text-org7b8ae4d">
<p>
Ekonomik bir şekilde verinin istenilen görüntüye dönüşmesini sağlamanın en önemli yolu olabilecek en az değişiklik ile bunu başarabilmek.
</p>

<p>
React&rsquo;in kabaca karmaşıklığı <code>O(n)3</code> ten <code>heuristic</code> yaklaşımla <code>O(n)</code>&rsquo;e cektigi ve <a href="https://legacy.reactjs.org/docs/reconciliation.html">ilham aldığı</a> bazı pratikler bunu mümkün kıldı.
</p>

<p>
Buradaki <code>diffing</code>&rsquo;e yardımcı olarak daha akıcı olarak veriyi ekrana yansıtabilecek yazılımı ortaya çıkabiliriz.
</p>
</div>
<h3><a id="nelere-dikkat-etmeliyiz" class="anchor" href="#nelere-dikkat-etmeliyiz">¶</a>Nelere dikkat etmeliyiz</h3><div class="outline-text-3" id="text-org05dad1a">
<p>
O nedenle kullandığınız framework&rsquo;un buna yardımcı olan yaklaşımlarını iyi anlamamız gerekiyor.
</p>

<p>
<a href="https://legacy.reactjs.org/docs/reconciliation.html">Reconcilation</a> olarak geçen bu yaklaşımda yeniden kullanalabilecek tipte elemanlar var ise yok edilmiyor. Listeler gibi tekrarlı görsellerin olduğu noktalarda <code>key</code>&rsquo;ler kullanılıyor.
</p>

<p>
SwiftUI kütüphanesi ise yine static typing&rsquo;den faydalanarak view&rsquo;lerin yokedilmesi ve tekrar kullanılabilir olması konusundan faydalanıyor. View&rsquo;lerin animasyonlu bir şekilde ekranda görüntülenmesini sağlamak istiyorsak ilgili tiplerin yeni renderde kaybolmadığına dikkat etmek önemli.
</p>

<p>
Çok basit iki örnekle açıklayalım:
</p>
<div class="highlight"><pre><span></span>  <span class="c1">// Burada farklı bir branching izlediğinden</span>
  <span class="c1">// yok olması ve oluşturulması gereken view&#39;ler oluyor</span>
  <span class="c1">// Animasyon verdiğinizde düzgün geçiş göremezsiniz.</span>
  <span class="kd">struct</span> <span class="nc">AnswerStateView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">State</span> <span class="kd">var</span> <span class="nv">isCorrect</span><span class="p">:</span> <span class="nb">Bool</span>

      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
          <span class="k">if</span> <span class="n">isCorrect</span> <span class="p">{</span>
              <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Correct&quot;</span><span class="p">).</span><span class="n">foregroundColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">green</span><span class="p">)</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Wrong&quot;</span><span class="p">).</span><span class="n">foregroundColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">red</span><span class="p">)</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></div>

<div class="highlight"><pre><span></span>  <span class="c1">// Burada farklı bir branching izlemeden aynı view olduğunu</span>
  <span class="c1">// anlayan sistem rahatlıkla animasyonu gerçekler ve gereksiz bir view yaratıp yok etmez.</span>
  <span class="kd">struct</span> <span class="nc">AnswerStateView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">State</span> <span class="kd">var</span> <span class="nv">isCorrect</span><span class="p">:</span> <span class="nb">Bool</span>

      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">Text</span><span class="p">(</span><span class="n">isCorrect</span> <span class="p">?</span> <span class="s">&quot;Correct&quot;</span> <span class="p">:</span> <span class="s">&quot;Wrong&quot;</span><span class="p">)</span>
            <span class="p">.</span><span class="n">foregroundColor</span><span class="p">(</span><span class="n">isCorrect</span> <span class="p">?</span> <span class="n">Color</span><span class="p">.</span><span class="n">green</span> <span class="p">:</span> <span class="n">Color</span><span class="p">.</span><span class="n">red</span><span class="p">)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></div>

<p>
Bu örneklerde görüldüğü üzere view eşlemeleri tipler üzerinden gerçekleşebilir.
</p>
</div>
<h3><a id="keyid-kullanımı" class="anchor" href="#keyid-kullanımı">¶</a>Key/Id kullanımı</h3><div class="outline-text-3" id="text-orgd4a1daa">
<p>
Listeler gibi view elemanlarında ise <code>id</code>&rsquo;ler üzerinden dinamik arayüz elemanları çizip eşleştirilebilir.
</p>

<p>
O nedenle ForEach gibi viewlerde SwiftUI <code>Identifiable</code> protokolu ile <code>id</code> parametresi gerektiriyor, ve onun uzerinden <code>reconciliation</code> yapiyor.
</p>

<div class="highlight"><pre><span></span>  <span class="kd">import</span> <span class="nc">SwiftUI</span>

  <span class="kd">struct</span> <span class="nc">City</span><span class="p">:</span> <span class="n">Identifiable</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nv">id</span><span class="p">:</span> <span class="nb">Int</span>
      <span class="kd">let</span> <span class="nv">name</span><span class="p">:</span> <span class="nb">String</span>
  <span class="p">}</span>

  <span class="kd">struct</span> <span class="nc">ContentView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nv">cities</span> <span class="p">=</span> <span class="p">[</span>
        <span class="n">City</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Istanbul&quot;</span><span class="p">),</span>
        <span class="n">City</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Ankara&quot;</span><span class="p">),</span>
        <span class="n">City</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">35</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Izmir&quot;</span><span class="p">),</span>
        <span class="n">City</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Bursa&quot;</span><span class="p">),</span>
        <span class="n">City</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;Antalya&quot;</span><span class="p">)</span>
      <span class="p">]</span>

      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">List</span> <span class="p">{</span>
              <span class="n">ForEach</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span> <span class="p">{</span> <span class="n">city</span> <span class="k">in</span>
                  <span class="n">Text</span><span class="p">(</span><span class="n">city</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>
</pre></div>

<p>
<code>Flutter</code> gibi kütüphanelerde ise <code>key</code>&rsquo;ler üzerinden ilgili veri için yeni bir view widget&rsquo;i gerekiyor mu sorusu cevaplanıyor.
Dikkat edilmesi gereken noktalardan bir tanesi liste elemanlarında <code>index</code>&rsquo;i <code>id</code> veya <code>key</code> olarak <b>kullanmamak</b>. Reorder durumlarında hatalara sebep olucaktır.
</p>

<p>
Bazende eşsiz rastgele bir id kullanarak bunu yapabiliriz diye düşünebiliriz. O durumda ilgili framework&rsquo;e yardım etmemiş ve performansı düşük bir kod yazmış oluruz.
</p>

<p>
Eğer elimizde bir &rsquo;id&rsquo; yok ise mümkün mertebe veri&rsquo;ye ait bir &rsquo;key&rsquo; çıkarma yoluna gidebiliriz, misal şehrin &rsquo;id&rsquo;leri yok ise şehir ismini &rsquo;id&rsquo; olarak düşünüp diğer verilerle <code>hash</code>&rsquo;leyip kullanabiliriz.
</p>

<p>
Verilerin declarative yaklaşımlı framework&rsquo;lerle çizilmesinde <code>state management</code> yani veri yönetimi bir başka saç ayağı.
</p>

<p>
Bu yazıda Veriden =&gt; Ekrana giden yolda tasarımın declarative yollar ile görselleştirilmesinden bahsettik.
</p>

<p>
İyi eğlenceler.
</p>
</div>
<h3><a id="kaynakça" class="anchor" href="#kaynakça">¶</a>Kaynakça</h3><div class="outline-text-3" id="text-orgf0ed846">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=8pDqJVdNa44">React belgeseli</a></li>
<li><a href="https://legacy.reactjs.org/docs/reconciliation.html">React Framework Heuristic Diffing</a></li>
<li><a href="https://rensbr.eu/blog/swiftui-diffing/">SwiftUI Diffing</a></li>
</ul>
</div>
</div></div></div><footer class="site-footer"><div class="container"><div class="row"><div class="column"><p><a href="https://mobilen.art/credits/">Atıflar</a> · <a rel="me" href="https://tr.linkedin.com/in/suat-karakusoglu">s13u</a></p><p>© 2023-2024 Mobilen</p></div><div class="column align-right"><p><a href="https://github.com/suatkarakusoglu/mobilen"><img src="https://mobilen.art/img/site_github_icon.png" style="width: 80px" alt="Github'da Katkıda Bulun"/></a></p></div></div></div><div class="container"><div class="row site-footer-tags"><a class="tag" href="https://mobilen.art/tags/yazılım/">Yazılım #35</a><a class="tag" href="https://mobilen.art/tags/ios/">iOS #25</a><a class="tag" href="https://mobilen.art/tags/araçlar/">Araçlar #8</a><a class="tag" href="https://mobilen.art/tags/apple/">Apple #8</a><a class="tag" href="https://mobilen.art/tags/android/">Android #8</a><a class="tag" href="https://mobilen.art/tags/tasarım/">Tasarım #6</a><a class="tag" href="https://mobilen.art/tags/xcode/">Xcode #5</a><a class="tag" href="https://mobilen.art/tags/kitap/">Kitap #5</a><a class="tag" href="https://mobilen.art/tags/terminal_komutları/">Terminal Komutları #4</a><a class="tag" href="https://mobilen.art/tags/swiftui/">SwiftUI #3</a><a class="tag" href="https://mobilen.art/tags/android_studio/">Android Studio #3</a><a class="tag" href="https://mobilen.art/tags/tüyo/">Tüyo #3</a><a class="tag" href="https://mobilen.art/tags/wwdc/">WWDC #2</a><a class="tag" href="https://mobilen.art/tags/swift/">Swift #2</a><a class="tag" href="https://mobilen.art/tags/belgesel/">Belgesel #2</a><a class="tag" href="https://mobilen.art/tags/flutter/">Flutter #2</a><a class="tag" href="https://mobilen.art/tags/haber/">Haber #2</a><a class="tag" href="https://mobilen.art/tags/güvenlik/">Güvenlik #1</a><a class="tag" href="https://mobilen.art/tags/biyografi/">Biyografi #1</a><a class="tag" href="https://mobilen.art/tags/ürün_yönetimi/">Ürün Yönetimi #1</a><a class="tag" href="https://mobilen.art/tags/i̇letişim/">İletişim #1</a><a class="tag" href="https://mobilen.art/tags/kotlin/">Kotlin #1</a><a class="tag" href="https://mobilen.art/tags/react/">React #1</a><a class="tag" href="https://mobilen.art/tags/carplay/">CarPlay #1</a><a class="tag" href="https://mobilen.art/tags/ai/">AI #1</a><a class="tag" href="https://mobilen.art/tags/template/">Template #1</a><a class="tag" href="https://mobilen.art/tags/debugging/">Debugging #1</a></div></div></footer></body></html>
